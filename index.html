<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Wireframe → SVG (Ortho, Minimal)</title>
<style>
  html, body { height: 100%; margin: 0; background:#fff; font-family: system-ui, sans-serif; }
  #wrap { max-width: 960px; margin: 24px auto; padding: 12px; }
  .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
  .panel { border: 1px solid #ddd; border-radius: 10px; padding: 10px; }
  #gl, #svg { height: 420px; background:#fff; }
  button { padding: 8px 12px; border:1px solid #ccc; border-radius:8px; background:#fff; cursor:pointer; }
</style>
</head>
<body>
<div id="wrap">
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
    <h1 style="font-size:18px; margin:0;">Wireframe → SVG (Ortho, Minimal)</h1>
    <button id="saveBtn">Save SVG</button>
  </div>

  <div class="row">
    <div class="panel">
      <div>WebGL (操作用)</div>
      <div id="gl"></div>
    </div>
    <div class="panel">
      <div>SVG プレビュー（ベクター）</div>
      <div id="svg"></div>
    </div>
  </div>
</div>

<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.0?module';
  import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js?module';

  const glWrap  = document.getElementById('gl');
  const svgWrap = document.getElementById('svg');

  // --- scene & camera (orthographic) ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);

  const frustumSize = 12;
  const aspect = 1; // 初期値（リサイズ時に更新）
  const camera = new THREE.OrthographicCamera(
    (-frustumSize * aspect) / 2,
    ( frustumSize * aspect) / 2,
     frustumSize / 2,
    -frustumSize / 2,
    -100, 1000
  );
  camera.position.set(10,10,10);
  camera.lookAt(0,0,0);

  // --- geometry: 1辺=1オブジェクト（編集しやすいSVG） ---
  function makeBoxEdges(size=1){
    const h=size/2;
    const V=[
      new THREE.Vector3(-h,-h,-h), new THREE.Vector3( h,-h,-h),
      new THREE.Vector3(-h, h,-h), new THREE.Vector3( h, h,-h),
      new THREE.Vector3(-h,-h, h), new THREE.Vector3( h,-h, h),
      new THREE.Vector3(-h, h, h), new THREE.Vector3( h, h, h),
    ];
    const E=[[0,1],[1,3],[3,2],[2,0],[4,5],[5,7],[7,6],[6,4],[0,4],[1,5],[2,6],[3,7]];
    const g=new THREE.Group();
    const mat=new THREE.LineBasicMaterial({color:0x000000});
    for(const [a,b] of E){
      const geom=new THREE.BufferGeometry().setFromPoints([V[a].clone(), V[b].clone()]);
      g.add(new THREE.Line(geom, mat));
    }
    return g;
  }
  const group=new THREE.Group();
  const steps=10;
  for(let i=0;i<steps;i++){
    const box=makeBoxEdges(1);
    box.position.set(i*1.2, i*0.7, 0);
    group.add(box);
  }
  scene.add(group);

  // --- renderer ---
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  glWrap.appendChild(renderer.domElement);

  // --- controls ---
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // --- SVG生成関数 ---
  function generateSVG() {
    // WebGLと同じサイズ計算を使用
    const rowElement = document.querySelector('.row');
    const panelWidth = (rowElement.clientWidth - 12) / 2; // gap分を引いて2分割
    const panelHeight = 420;
    
    // シーンからSVGを生成
    let svgContent = `<svg width="${panelWidth}" height="${panelHeight}" xmlns="http://www.w3.org/2000/svg">`;
    svgContent += `<rect width="100%" height="100%" fill="white"/>`;
    
    // 各ボックスのエッジをSVGパスとして描画
    group.children.forEach((box, boxIndex) => {
      // ボックスの各エッジを処理
      box.children.forEach((line, lineIndex) => {
        const geometry = line.geometry;
        const positions = geometry.attributes.position;
        
        if (positions && positions.count >= 2) {
          const start = new THREE.Vector3();
          const end = new THREE.Vector3();
          
          start.fromBufferAttribute(positions, 0);
          end.fromBufferAttribute(positions, 1);
          
          // ワールド座標に変換
          start.applyMatrix4(box.matrixWorld);
          end.applyMatrix4(box.matrixWorld);
          
          // プロジェクション座標に変換
          const startProj = start.clone().project(camera);
          const endProj = end.clone().project(camera);
          
          // SVG座標に変換
          const x1 = (startProj.x + 1) * panelWidth / 2;
          const y1 = (1 - startProj.y) * panelHeight / 2;
          const x2 = (endProj.x + 1) * panelWidth / 2;
          const y2 = (1 - endProj.y) * panelHeight / 2;
          
          svgContent += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="black" stroke-width="1"/>`;
        }
      });
    });
    
    svgContent += '</svg>';
    return svgContent;
  }

  // --- resize ---
  function resize(){
    // 両方のパネルが同じサイズになるように、グリッドの1つのセルのサイズを取得
    const rowElement = document.querySelector('.row');
    const panelWidth = (rowElement.clientWidth - 12) / 2; // gap分を引いて2分割
    const panelHeight = 420;
    
    // WebGLレンダラーのサイズ設定
    renderer.setSize(panelWidth, panelHeight);
    
    // カメラのアスペクト比を設定
    const aspect = panelWidth / panelHeight;
    camera.left = (-frustumSize * aspect) / 2;
    camera.right = (frustumSize * aspect) / 2;
    camera.top = frustumSize / 2;
    camera.bottom = -frustumSize / 2;
    camera.updateProjectionMatrix();
  }
  
  // 初期化時に一度だけリサイズ
  resize();
  
  // ウィンドウリサイズ時のみ監視
  window.addEventListener('resize', resize);

  // --- loop ---
  function tick(){
    controls.update();
    renderer.render(scene, camera);
    
    // SVGプレビューを更新
    const svgContent = generateSVG();
    svgWrap.innerHTML = svgContent;
    
    requestAnimationFrame(tick);
  }
  tick();

  // --- save svg ---
  document.getElementById('saveBtn').onclick = ()=>{
    const svgContent = generateSVG();
    const blob = new Blob([svgContent], {type:'image/svg+xml'});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement('a'), {href:url, download:'wireframe.svg'});
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 500);
  };
</script>
</body>
</html>
